# Tutorial: Creating a simple clicker game in Castle Game Engine and Castle Editor
Yevhen Loza, Andrzej KilijaÅ„ski, Michalis Kamburelis
include::locale/attributes.adoc[]
:toc: left
:toclevels: 1
:sectnums:
:source-highlighter: coderay
:docinfo1:
:imagesdir: images

## Abstract

This tutorial is aimed at new users, who have some minor knowledge of Pascal and general concepts of programming and game development. It will cover all steps necessary from creation and setting up of the project, to a small but finished game.

Required level of Pascal knowledge: Low.

Required level of Castle Game Engine knowledge: Zero.

Expected duration: 3-4 hours.

## Goal of this tutorial

(In this tutorial we'll learn how to)

(Simple introduction at the beginning with game rules, screenshot, download button)

You can download the compiled version of the game at https://decoherence.itch.io/button-clicker-game (Windows, Linux, Android).

## Set up the Environment

For this tutorial we shall be using Lazarus IDE. We shan't use GUI provided by Lazarus, therefore this is not a requirement, just a personal preference. The tutorial can be easily followed using any other IDE or even a text editor capable of editing FreePascal code.

Before we start:

* Make sure that Lazarus + FPC are properly installed.

* Make sure Castle Game Engine packages are installed, compiled and working properly. We shall be using `castle_base.lpk` and `castle_window.lpk` packages.

* Make sure that `alternative_castle_window_based_on_lcl.lpk` is _**NOT**_ installed in Lazarus, as it will conflict with `castle_window.lpk` package we shall be using.

* Make sure the required libraries are installed in the system or available on system $PATH. Try compiling a few examples from `examples` folder to make sure they're working.

* Make sure system environment variables required for Castle Game Engine and Castle Editor are set up properly.

* Make sure Castle Editor, set up properly, is compiled and ready to use.

More details can be found in https://castle-engine.io/documentation.php[Official Documentation].

## Creating an Empty Project

### Creating a Project in Castle Editor

Run Castle Editor and select "New Project":

image::a-001-000-new-project.png[]

It will open "New Project" dialogue, which will ask us to select template, name and folder for the project:

image::a-002-000-new-project-parameters.png[]

In this tutorial we'll be using the most basic template - "Empty".

Next, let's write a name for the project "ButtonClickerGame". Note that the name cannot start with a number. And it's best to avoid non-ASCII characters or spaces in project name or path. Also it's a good idea to limit the path to the project to 255 symbols, which might cause bugs on some exotic platforms.

The filled-in form should look something like that:

image::a-003-000-new-project-filled-in.png[]

All that's left to do is to press "Create Project" button. This will create a simple dummy project we can start filling with our game-specific code and assets.

### What's inside?

Castle Editor now created our project, that initially contains:

image:a-004-000-initial-game-folder.png[]

* `code` folder where the code of the project is stred. We shall also store our own units in this folder.

- `code/gameinitialize.pas` - pascal unit for initialization of the game.

- `code/gamestatemain.pas` - pascal unit for Main State of the User Interface. It describes how this State should work.

* `data` folder where the data for our project is located. We shall be adding our game data inside there as we go.

- `data/CastleSettings.xml` - settings of our game project, can be edited with any text editor like notepad.

- `data/state_main.castle-user-interface` - design of the Main State. We can edit it with Castle Editor.

- `data/README.txt` - short reminder of what the `data` folder is and where to get additional information. We don't need this file and it can be deleted right away.

* `.gitignore` a gitignore file that gives us a ready-to-use list of ignored files when using https://git-scm.com/[GIT] version control system. It's already fine-tuned to include all autogenerated and temporary files that are created during the game compilation. If we already compiled the game, there will be additional files in our folder (e.g. `ButtonClickerGame.exe`) that are ignored by GIT clients, and also not listed in the current list. You can find more info about this file in https://git-scm.com/docs/gitignore[GIT documentation].

* `ButtonClickerGame_standalone.lpi` - Lazarus/FreePascal project information. It contains settings and parameters for our project, already fine-tuned to use with Castle Game Engine.

* `ButtonClickerGame_standalone.lpr` - Lazarus project file - an autogenerated file that enables convenient working with our project from Lazarus. It can be opened it in Lazarus or any text editor. `lpr` stands for "Lazarus project" but in everything else it's equal to a normal `pas` file.

* `castleautogenerated.pas` - a Pascal unit with automatically generated additional information about the project.

* `CastleEngineManifest.xml` - a Castle Game Engine manifest file, that describes some important settings for the project that control how the project is compiled, packaged and distributed.

* `README.md` - a short readme file for our project - or rather a place to get us started writing our own.

Note that we on the bottom of the Castle Editor we can also see all the project files:

image:a-004-010-initial-game-folder-castle-editor.png[]

### Running the project

Let's open freshly created `ButtonClickerGame_standalone.lpi` in Lazarus. We can immediately compile and run it:

image::a-005-000-run-run.png[]

It's a template but it's a fully functional minimalistic project, that we can compile and run. The template will show us an empty dark gray window with a lone FPS counter:

image::a-006-000-empty-project-run.png[]

As we're going to use "Run" feature very often to check if our game works as expected after recent changes, it's good to know that we can do the same using F9 hotkey.

Note that there are also several useful options here:

- **Compile** - Will compile only changed files, without running the game.

- **Build** - Will compile all files in the project, without running the game.

- **Clean up and Build** - Will recompile everything clean, Castle Game Engine included, again, without running the game.

Note, that usually we don't need to use any of those options, as Lazarus/FPC is smart enough to properly understand what has been changed and what should be recompiled to create a proper executable binary. However, in case of working with large/huge projects sometimes it's necessary to make a proper clean up.

There's also a set of convenient buttons on the Lazarus Toolbar:

image::a-007-000-toolbar-run.png[]

We can use the green triangle button to quickly compile and run the game. There is also a green triangle with a red cross that will do the same, except for disabled debugging - we will get less information in case the game crashes, but the game will run notably faster.

Note, that Castle Editor enables us to do absolutely the same through "Run" menu:

a-008-000-run-castle-editor.png

Here we can the same way:

- **Compile** - Will compile the game, without running it.

- **Compile And Run** - Will compile the game, and run it.

- **Run (Without Compiling)** - Will run the executable, if it is available.

### What do we have here?

Let's have a closer look at what code is there inside the project.

Again as a personal preference - there are many other ways to, we shall use Project Inspector to find our way around the project. If it is not visible by default we can easily activate it by going to Project -> Project Inspector:

image::a-009-000-project-inspector-menu.png[]

Right now our Project inspector contains files automatically added by Castle Editor:

image::a-010-000-project-inspector.png[]

Double-clicking the file in the Project Inspector opens the file for us in the Source Editor.

First of all, let's take a look at `code/gameinitialize.pas`:

### GameInitialize unit

This is the main hub for our game. The game starts and ends here. It contains:

- `interface` section. It's empty in this unit, so nothing to do here.

- `implementation` section. All of our game start-up happens here.

- `initialization` section. Core instructions on how to prepare and launch our game. Note, that on some platforms (mobile first of all) some operations are not allowed to run during `initialization` (e.g. reading files), so it's a good idea to keep this section to minimum and not add anything here unless we are absolutely sure what we are doing is safe.

You can read a bit more on Unit structure at https://wiki.freepascal.org/Unit#Format

Let's go into `implementation` section and see `uses` section of it:

[source,pascal]
----
uses SysUtils,
  CastleWindow, CastleLog, CastleUIState
  {$region 'Castle Initialization Uses'}
  // The content here may be automatically updated by CGE editor.
  , GameStateMain
  {$endregion 'Castle Initialization Uses'};
----

Overall it describes all the units that are available to the current unit - we can use variables and types from those units inside here.

- `SysUtils` - A generic unit, that adds a lot of useful functions and procedures.

- `CastleWindow, CastleLog, CastleUIState` - Castle Game Engine features that are used within this unit.

- 

==================
for publishing - now it's finally time to take a look at castleautogenerated.pas